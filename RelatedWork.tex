\section{Introduction}
Cloud computing was introduced a decade ago with the promise of seemingly infinite computing resources available on demand \cite{Armbrust09abovethe}. This model has proved to be effective for scaling up search engines\cite{7073834}, social networks\cite{6596496}, and content service providers\cite{6915771} to billions of users around the world. However, this centralized model is being challenged by the emergence of a new computing paradigm and associated technologies i.e. Internet of Things (IoT).

The Internet of Things paradigm (IoT) fosters the connection of large numbers of sensors to the network. According to Cisco systems~\cite{ciscoGlance}, 500 billion IoT devices are expected to be connected to the Internet by 2030, and mearly 50\% of the data produced worldwide will be generated by IoT sensors~\cite{McAuley}. As the volume of data generated from the devices increases, moving data from the edge of the network to the Cloud might not be feasible due to bandwidth constraints~\cite{8289317}. Furthermore, as low latency and location-aware applications emerge~\cite{7389122}, transfering all the data to the Cloud will not satisfy the low latency or location-aware constraints that the IoT applications expect. In addition, some applications, deal with sensitive and personal data, making it not possible to send the data to the Cloud due to privacy concerns~\cite{7849185}. For example, Toyota estimates that the amount of data flowing between vehicles and servers will reach 10 exabytes per month by 2025~\cite{Toyota}. Another example is commercial jets, which generate 10 TB of data for every 30 minutes of flight, making it impractical to transport all the data from the edge to the Cloud~\cite{ciscoJet}. 

Edge computing has emerged as a potential approach for handling the large quantity of data generated by connected devices. It leverages the ability to execute computations and process data at the edge of the network, closer from the location of data producers. Edge computing leverages smaller servers or single board computers that are widely distributed close to the edge to improve delays. Edge middleware is the essential software stack that serves as an interface between the Cloud and the IoT devices, supporting data discovery, communication and processing between edge devices and cloud services. %\hl{In this context, edge middleware platforms were created to ease the IoT application development by providing the necessary tools.} 

The realization of edge-based middleware platforms presents several conceptual and technical challenges. We believe that the seamless integration of edge and Cloud systems is one of the main challenges that prevent the efficient utilization of IoT. Without such an integration, developers must explicitly manage the platform as a unified set of resources to orchestrate computations, coordinate devices, and deliver data to users. As a result, there has been a substantial amount of research towards building edge-based middleware, addressing key crosscutting challenges, such as device discovery, scalability, and privacy and security. It is therefore important to understand the current state-of-the-art edge-based middleware and identify the gaps that may exist.

\begin{figure}[hbt!]
    \centering
    \includegraphics[scale=0.7]{Figures/IoTArchW.pdf}
    \caption{Edge-based middleware reference architecture consisting of four layers, each of them with their respective components.}
    \label{fig:EdgeArch}
\end{figure}

\section{Edge-based Middleware Architecture}\label{sec:arch}

Extensive research and development have been put into creating edge-based middleware systems. There are currently more than 100 edge-based middleware platforms in the market today and the number is continuously growing~\cite{List}. However, not every platform is designed with the same capabilities or architecture. Despite the diversity and large number of edge-based middleware systems, two common architectures emerge:

The majority of IoT platform's architecture follows the Cloud-centric approach. They are built on the premise that ingestion, management, and processing of IoT data can be done in the Cloud, without any edge computing capabilities. Some examples are: Particle Cloud~\cite{Particle}, Salesforce IoT Cloud~\cite{Salesforce_IoT_Cloud} and If This Then That~\cite{IFTTT}.

The other approach is the end-to-end architecture or edge-based middleware architecture built on the premise that edge-processing can save huge costs to clients. %An Internet of Things (IoT) gateway or middleware is a physical device that serves as the connection point between the Cloud and the edge sensors. The gateway or edge middlewares are, usually deployed on single board computers (e.g., Raspberry Pi's), minicomputers, or smart devices (e.g., smartphones, TVs, or refrigerators) to provide management, connectivity, and data pre-processing for sensors.

In this survey, we focus on the end-to-end or edge-based middleware architecture, since the Cloud-centric approach will not be able to satisfy the requirement of the IoT applications presented in section~\ref{sec:usecases}. In order to compare and contrast all the existing state-of-the-art edge-based middlewares, we carefully studied the requirements and limitations of the IoT applications and came up with a four-layer edge-based middleware framework that satisfies all the requirements and limitations of the IoT applications, and each of the middlewares should consist. Figure~\ref{fig:EdgeArch} presents the layers and components that need to be included in an edge-computing solution. The edge-based middleware architecture is composed of four separate layers: resource management, data processing, service , and security.

\begin{table}[hbt!]
\caption{Design goals of the resource management layer components of the cited papers in this survey.}
\label{tab:resource}
\resizebox{\textwidth}{!}{%
\begin{tabular}{c|c|c|c|c|c|c|}
\cline{2-7}
                                          & \multicolumn{2}{c|}{Resource Discovery}               & \multicolumn{2}{c|}{Resource Monitoring}              & \multicolumn{2}{c|}{Resource Mobility}                \\ \hline
\multicolumn{1}{|c|}{Paper}               & Distributed               & \begin{tabular}[c]{@{}c@{}}Low \\Overhead\end{tabular}             & Distributed               & \begin{tabular}[c]{@{}c@{}}Low \\ Overhead\end{tabular}              & Distributed               & \begin{tabular}[c]{@{}c@{}}Low \\ Overhead\end{tabular}              \\ \hline
\multicolumn{1}{|c|}{Paganelli et al.~\cite{article}}    & \checkmark & \checkmark &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Liu et al.~\cite{6680268}}          & \checkmark &                           &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Cirani et al.~\cite{6899579}}       & \checkmark & \checkmark &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Jara et al.~\cite{6550579}}         &                           & \checkmark &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Zhou et al.~\cite{6664533}}         &                           & \checkmark &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Tanganelli et al.~\cite{8086146}}   &                           &                           & \checkmark & \checkmark &                           &                           \\ \hline
\multicolumn{1}{|c|}{M{\"a}enp{\"a}{\"a} et al.~\cite{Maenpaa2012}}      &                           &                           & \checkmark & \checkmark &                           &                           \\ \hline
\multicolumn{1}{|c|}{SEGUE~\cite{SEGUE}}               &                           &                           &                           &                           & \checkmark & \checkmark \\ \hline
\multicolumn{1}{|c|}{Chaufournier et al.~\cite{Chaufournier:2017}} &                           &                           &                           &                           & \checkmark & \checkmark \\ \hline
\multicolumn{1}{|c|}{Farris et al.~\cite{Farris:2017}}        &                           &                           &                           &                           & \checkmark & \checkmark \\ \hline
\end{tabular}
}
\end{table}

\subsection{Resource Management Layer}
The resource management layer is dedicated to the discovery, identification and allocation of available resources. The challenge of the resource management layer is in managing these limited and geo-distributed resources efficiently. The resource management layer consists of the following components: resource discovery, resource monitoring, and resource mobility. Table~\ref{tab:resource} summarizes the design goals of each of the works focused on the resource management layer.

\subsubsection{Design Goals}

The following are the design goals that need to be taken into consideration when developing any of the components of the resource management layer.
\\\\
\textbf{Low Overhead:} The algorithms and protocols of the resource management layer need to offer low runtime overhead when deployed in performance-limited hardware platforms.
\\\\
\textbf{Distributed:} The resource management components also need to be designed in a distributed fashion in order to scale with the number of applications running in the system and with the number of IoT and edge devices.

%\\\\
%\textbf{Dynamic:} The resource management layer should also be capable to make proactive decisions, dynamic deployment, and intelligent decisions based on the understanding of the context of the environments, users and applications requirements.



\subsubsection{Resource Discovery}
The resource discovery component is responsible for efficiently identifying and discovering the geo-distributed IoT sensors. The following are some of the work focused on the resource discovery component. 

Paganelli et al.~\cite{article} present a service for discovering Internet of Things resources. The service uses a peer-to-peer approach along with distributed hash table (DHT) techniques  to support the discovery of distributed resources, the system guarantees scalability, robustness, and maintainability. Paganelli et al. meet both design goals since they use a distributed architecture by the means of a P2P architecture to support the number of growing devices and offers a low-overhead algorithm.

Liu et al.~\cite{6680268} propose a distributed architecture for resource discovery, designed to be used in Machine-to-Machine applications.
The architecture uses an overlay network composed of peer nodes to distribute workload,and eliminating the single point of failure. Liu et al. resource discovery mechanism only meet the distributed goal since the system is build using a peer-to-peer architecture to efficiently discover the resources in a decentralized manner. It does not meet the low overhead since it used HTTP to communicate and discover resources~\cite{8088251}. The reason being that HTTP runs on TCP, therefore it incurs all TCP connection overheads for connection establishment and closing~\cite{8088251}.

%The architecture is designed to support heterogeneous devices in resource description registration and discovery of resource value. It achieves interoperability among heterogeneous devices in disparate networks and enables resource access from the Internet. In the DRD, a resource registration component is designed for storing resource descriptions; a resource discovery component is designed to retrieve resource values on behalf of clients after getting address information by looking up resource descriptions. 


Cirani et al.~\cite{6899579} also present a Peer-to-Peer architecture for service and resource discovery that can be applied for the Internet of Things applications. Cirani et al. resource discovery mechanism satisfies both goals since it used a distributed P2P architecture for discovering resources and it used CoAP a lightweight messaging system that uses UDP~\cite{8088251} for keeping track of all the resources.

%Utilization of P2P technologies enables deployment of distributed and large scale infrastructure for SD. IoT gateway acts as a backbone of the SD architecture. The gateway keeps track of anything joining or leaving its network and updates the list maintained at its CoAP server. 

Jara et al.~\cite{6550579} presents a centralized mechanism for discovering devices based on context and location. Jara et al. only satisfy the low overhead goal of the resource discovery mechanism since it uses a centralized architecture for discovering devices. It is well-known that centralized architectures have a single point-of-failure and present some scalability concerns when the number of IoT devices grows~\cite{6680268}. 

%An infrastructure called 'digcovery' used for maximizing efficiency and sustainability of deployments offers the framework to allow users to register/include their own sensors into a common infrastructure, and access/discover the available resources through a mobile phone.

Zhou et al.~\cite{6664533} presents a service discovery algorithm and architecture designed for the Internet of Things. The work focuses on the context and location aware discovery. They first present an architecture called "Digcovery" to support the large number of IoT devices. And finally they present a search engine to offer query, look-up and filtering support. Zhou et al. only satisfy the low-overhead goal since the resource discovery mechanism claims that the algorithm has good scalability, and it can be applied to different fields. Only the domain ontology needs to be replaced.

\subsubsection{Resource Monitoring}
The resource monitoring component is responsible for controlling and managing hardware and software infrastructures. It also provides information and performance indicators for both platforms and applications to assist in the decision of allocating the resources. In addition, it monitors the state of the resources in the event of failure. The following are some of the work focused only on the resource monitoring component.

Tanganelli et al.~\cite{8086146} propose an edge-centric architecture that uses the CoRE Resource Directory interface and the CoAP protocol to enable resource monitoring and discovery for IoT applications. This approach is able to satisfy both design goals since it is distributed, in the means of a P2P network, and achieves low overhead since they run their experiments on emulated embedded devices and achieve millisecond latencies.

M{\"a}enp{\"a}{\"a} et al.~\cite{Maenpaa2012} propose an architecture that focuses on the resource discovery and monitoring of wide area sensors and actuators. The architecture enables a federation of geographically distributed Wireless Sensor Networks (WSNs)  using a peer-to-peer network. This approach satisfies both design goals.

\subsubsection{Resource Mobility}
The resource mobility component is responsible for moving computations between edge nodes in order to achieve the requirements of the IoT applications. The following are some of the work focused only on the resource mobility component.

SEGUE~\cite{SEGUE} is a migration system, that achieves optimal migration decisions by using the Markov Decision Process (MDP) to perform migration decisions. SEGUE meets all the design goals since it was carefully evaluated to showcase the real-time performance, scalability, and dynamicity by using real mobility trace of 320 taxis in Rome. 

Chaufournier et al.~\cite{Chaufournier:2017} relies on multi-path TCP, an effort to use multiple paths to maximize resource usage and increase redundancy. This techniques aims at improving the migration time of virtual machines. Chaufournier et al. resource mobility approach also achieves all the goals since it proposed the uses of multi-path TCP and claims that increases the migration throughput by 6x and reduces the time by 50\% in some cases.

Farris et al.~\cite{Farris:2017},presents two Integer Linear Problem optimization schemes, with the pourpus of reducing the quality of service when performing migrations at the edge of the network. Farris et al. resource mobility also meets all the goals since it was designed to cope with the limitation of resource-constrained edge nodes and showcased the scalability in terms of users and the dynamicity of the algorithm.

\begin{table}[h!]
\caption{Design goals of the data processing layer components of the cited papers in this survey.}
\label{tab:processing}
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c|}
\cline{2-13}
                                   & \multicolumn{3}{c|}{Data Ingestion}                                 & \multicolumn{3}{c|}{Data Analysis}                                                & \multicolumn{3}{c|}{Data Storage}                                                 & \multicolumn{3}{c|}{Data Query}                                                   \\ \hline
\multicolumn{1}{|c|}{Project}        & \rotatebox[origin=c]{90}{Real-Time} & \rotatebox[origin=c]{90}{Distributed}               & \rotatebox[origin=c]{90}{Scalable}                  & \rotatebox[origin=c]{90}{Real-Time}                 & \rotatebox[origin=c]{90}{Distributed}               & \rotatebox[origin=c]{90}{Scalable}                  & \rotatebox[origin=c]{90}{Real-Time}                 & \rotatebox[origin=c]{90}{Distributed}               & \rotatebox[origin=c]{90}{Scalable}                  & \rotatebox[origin=c]{90}{Real-Time}                 & \rotatebox[origin=c]{90}{Distributed}               & \rotatebox[origin=c]{90}{Scalable}                  \\ \hline
\multicolumn{1}{|c|}{Apache Kafka~\cite{kafka}} &             & \checkmark & \checkmark &                           &                           &                           &                           &                           &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Mosquitto~\cite{mosquitto}}    &             & \checkmark & \checkmark &                           &                           &                           &                           &                           &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{RabbitMQ~\cite{RabbitMQ}}     &             & \checkmark &                           &                           &                           &                           &                           &                           &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{ActiveMQ~\cite{HiveMQ}}     &             & \checkmark &                           &                           &                           &                           &                           &                           &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Heron~\cite{heron}}        &             &                           &                           &                           & \checkmark & \checkmark &                           &                           &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Storm~\cite{storm}}        &             &                           &                           &                           & \checkmark & \checkmark &                           &                           &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Flink~\cite{flink}}        &             &                           &                           &                           & \checkmark & \checkmark &                           &                           &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{MillWheel~\cite{millwheel}}    &             &                           &                           &                           & \checkmark & \checkmark &                           &                           &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Spark~\cite{spark}}        &             &                           &                           &                           & \checkmark & \checkmark &                           &                           &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{ApacheEdgent~\cite{edgent}} &             &                           &                           & \checkmark & \checkmark & \checkmark &                           &                           &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{LMC~\cite{8102173}}          &             &                           &                           & \checkmark &                           & \checkmark &                           &                           &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{DataFlog~\cite{DataFog:2018}}     &             &                           &                           &                           &                           &                           & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark \\ \hline
\multicolumn{1}{|c|}{FogStore~\cite{Gupta:2018, Mayer2017FogStore}}     &             &                           &                           &                           &                           &                           & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark & \checkmark \\ \hline
\multicolumn{1}{|c|}{Moon et. al.~\cite{8190803}} &             &                           &                           &                           &                           &                           &                           &                           &                           &                           & \checkmark & \checkmark \\ \hline
\multicolumn{1}{|c|}{IOTMDB~\cite{6468294}}       &             &                           &                           &                           &                           &                           &                           &                           &                           &                           & \checkmark & \checkmark \\ \hline
\end{tabular}
\end{table}

\subsection{Data Processing Layer}

The data processing layer is in charge of the consolidation of data from multiple producers, along with its processing and delivery.  Current approaches in data processing are known to be data-intensive process. The frequent operations on disk results in the inability to perform real-time data analytics when executed on edge constrained devices.  The data processing layer consists of four components: ingestion, analysis, storage, and query. Table~\ref{tab:processing} summarizes the design goals of each of the works focused on the data processing layer.
\subsubsection{Design Goals}

The following are the design goals that need to be taken into consideration when designing any of the components of the data processing layer.
\\\\
\textbf{Distributed:} The data processing components should support distributed information processing, distributed computing capabilities, distributed storage and query. In order to address the variable number of devices, services, and users at any given point in time.
\\\\
\textbf{Scalable:} The scalable term refers to the ability of the data processing component to handle a growing number of
clients. The data processing components also need to be scalable also to address the needs of a variable number of devices, services, and users. 
\\\\
\textbf{Real-Time:} The real-time term refers to the ability to achieve low processing latency as the number of messages increases. The data processing components need to be able to process data in real-time either in edge constrained devices such as Raspberry Pis or smartphones and the cloud. Since IoT applications are latency sensitive as we described in section~\ref{sec:usecases}. 

\subsubsection{Data Ingestion}

The data ingestion component aggregates data from multiple producers and sources in order to enable processing through pipelines. The following works focused solely on the data ingestion component.

Apache Kafka~\cite{kafka} is one of the most popular frameworks available, it is an open-source framework used for building real-time data pipelines and streaming apps. Apache Kafka meets three of the four design goals, the reason Apache Kafka does not offer real-time processing at the edge of the network, because it was not designed to be deployed in constrained devices, as it was demonstrated in this work\cite{8778344}.

Mosquitto~\cite{mosquitto} is a lightweight open-source publish/subscribe messaging broker designed for the Internet of Things. It implements the lightweight MQTT protocol, to transport the messages, making it suitable for low-power devices. Even though Mosquitto was created for the need to achieve real-time message handling, Scalagent published a survey where they stress test the Mosquitto and show that it can succeed at handling 60,000 publishers but it requires high transmission latency and high CPU usage~\cite{mqtt}. For those reasons Mosquitto only satisfies the scalability and distributed and scalable design goals.

RabbitMQ~\cite{RabbitMQ} is also a lightweight publish/subscribe messaging broker, designed to be deployed in the cloud.
Similarly to Mosquitto, RabbitMQ in the scaleagent tests shows that it can only handle 8,000 publishers producing 8,000 messages per second, and is not able to achieve real-time analytics~\cite{mqtt}. In this case RabbitMQ only satisfies the distributed goal since it can only support 8,000 publishers, and as mentioned earlier, current city-scale experimental research facilities envision the deployment of 20,000 to 40,000 sensors~\cite{smartsantander}.

ActiveMQ~\cite{HiveMQ} its an open-source messaging broker, that supports numerous industry-standard protocols. ActiveMQ also suffers from the same problems as RabbitMQ since it has high message transmission latency and cannot handle more than 20.000 publishers~\cite{mqtt}.

\subsubsection{Data Analysis}

Data analysis is the process of analyzing large volumes of data to discover useful information and perform informed decisions. The following are some of the work focused on the data analysis component.

Heron~\cite{heron} is a real-time analytics platform developed by Twitter. It is designed for speedy performance, low latency, isolation, and reliability. Heron meets all the design goals except for the real-time data analytics at the edge because it was designed to be deployed in large clusters at the core of the network.

Apache Storm~\cite{storm} is an open-source distributed real-time stream processing system. Similarly, Storm was also designed to be deployed in the Cloud.

Flink~\cite{flink} is a distributed processing engine for performing stream processing applications over unbounded and bounded data streams. Flink was also designed to be deployed in the Cloud and not for the edge.

MillWheel~\cite{millwheel} is a framework for building low-latency data-processing applications that was designed and build by Google. MillWheel, just like Heron, Storm, and Flink, was designed to be deployed in large clusters in the Cloud.

Spark~\cite{spark} is an open-source distributed general-purpose stream processing and batch processing framework witch allow to perform in-memory analytics. Spark, just like Heron, Storm, and Flink, was designed to be deployed in large clusters in the Cloud.

Apache Edgent~\cite{edgent} is a micro-kernel framework designed to be deployed in small footprint edge devices, enabling local, real-time analytics at the edge of the network. Apache Edgent is a stream processing engine that was designed to be deployed on edge devices, allowing it to achieve all the design goals.

LMC~\cite{8102173} enables cross-platform code execution on constrained IoT devices. LCM meets the real-time and the scalable design goals since it was designed to constrained devices , but it doesn't meet the distributed goal since there is no currently not supported.

\subsubsection{Data Storage}

Due to the ever-increasing deployment of bandwidth-intensive IoT platforms (especially cameras), there is an increasing pressure on the bandwidth to transport data back and forth between the edge and the Cloud. There is a need for a more efficient management and computation of the data at the edge of the network. Building a storage system on an edge computing infrastructure has its own set of particular challenges. The wide geo-distribution and heterogeneous and constrained natures of this infrastructure require data-partitioning and replication policies that are commensurate with the latency requirements of the applications. The following are some of the work focused on the data storage component.

DataFlog~\cite{DataFog:2018} is a distributed indexing mechanism that performs data placement (both among edge nodes, and between the edge and the Cloud) based on spatiotemporal attributes to support efficient queries involving multiple edge nodes. DataFlog is able to achieve all the design goals for the data storage layer since it uses distributed indexing mechanism, it supports efficient queries and it can scale since it uses a P2P network and can be deployed in any environment.

FogStore~\cite{Gupta:2018}~\cite{Mayer2017FogStore} is distributed key-value storage system tailored for the edge of the network. FogStore uses a fog-aware replica placement, and a context-sensitive differential consistency strategies to satisfy the requirements of the Edge and the Fog. FogStore was designed by the same authors of DataFog and it also meets all the design goals, just like DataFlog.

\subsubsection{Data Query}

Similarly to the data storage, once data has been stored it needs to be accessed as well. The following are some of the research work on creating edge query systems. The following are some of the work focused on the data query component.
 
Moon et al.~\cite{8190803} propose a data management and searching system based on blockchain which ensures security. Moon et al. are able to meet all the goals for the data query layer except for the real-time design goal since they are using the blockchain Proof-of-Work consensus algorithm and it is known that the time to perform a computation does not increase linearly as the number of nodes increases.

IOTMDB~\cite{6468294} is an IoT storage solution based on NoSQL (Not Only SQL), to solve the storage and management problems of large volumes of IoT data. IOTMDB is able to satisfy all the design goals except for the real-time, since storing 1,000 records can take up to 2 seconds since other frameworks such as RocksDB can store 1,000 records in less than 60 ms~\cite{8778344}.

\begin{table}[h!]
\caption{Design goals of the service layer components of the cited papers in this survey.}
\label{tab:service}
\resizebox{\textwidth}{!}{%
\begin{tabular}{c|c|c|c|c|c|c|c|}
\cline{2-8}
                                       & \multicolumn{2}{c|}{Rule Engine}                      & \multicolumn{2}{c|}{Programming Model}                & \multicolumn{3}{c|}{Workflow Orchestrator}                                        \\ \hline
\multicolumn{1}{|c|}{Paper}            & Scalable                  & \begin{tabular}[c]{@{}c@{}}Low \\ Overhead\end{tabular}              & Expressive                 & Extensible                  & Dynamic                   & Scalable                  & \begin{tabular}[c]{@{}c@{}}Low \\ Overhead\end{tabular}              \\ \hline
\multicolumn{1}{|c|}{Chui et. al.~\cite{5277977}}     & \checkmark & \checkmark &                           &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Lica et. al.~\cite{7314063}}     &        \checkmark                   &                           &                           &                           &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Mobile-Fog~\cite{Hong:2013}}       &                           &                           & \checkmark & \checkmark &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Rabel~\cite{ravel-riliskis-iotapp15}}            &                           &                           &        \checkmark                   & \checkmark &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Fabryq~\cite{Etemadi2014FabryqUP}}           &                           &                           &       \checkmark                     &          \checkmark                  &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{FogFlow~\cite{8022859}}          &                           &                           & \checkmark & \checkmark &                           &                           &                           \\ \hline
\multicolumn{1}{|c|}{Eidenbenz et al.~\cite{Eidenbenz:2016}} &                           &                           &                           &                           &                           &                           & \checkmark \\ \hline
\multicolumn{1}{|c|}{Taneja et al.~\cite{Taneja:2017}}    &                           &                           &                           &                           &                           & \checkmark & \checkmark \\ \hline
\multicolumn{1}{|c|}{DROPLET~\cite{8457776}}          &                           &                           &                           &                           & \checkmark & \checkmark & \checkmark \\ \hline
\multicolumn{1}{|c|}{Ghosh et al.~\cite{Ghosh:2018}}     &                           &                           &                           &                           & \checkmark &                           &                           \\ \hline
\end{tabular}
}
\end{table}

\subsection{Service Layer}
The service Layer defines an application's set of available operations to the end user. The service layer is composed of three components: rule engine, programming model, and workflow orchestrator. Table~\ref{tab:service} summarizes design goals of each of the works focused on the service layer.

\subsubsection{Design Goals}

The following are the design goals that need to be taken into consideration when creating any of the components of the service layer.
\\\\
\textbf{Low Overhead} The service layer components need to be able to process data in real-time, i.e. providing fast analysis and data queries when deployed in performance-limited hardware platforms.
\\\\
\textbf{Scalable} The service layer components need to offer good scalability, since there is going to be a large number of rules and a large number of operators that need to be placed.
\\\\
\textbf{Dynamic} This design goal only applies to the workflow orchestrator. The workflow ochestrator needs to be able to orchestrate the workflows based on the runtime characteristics of the nodes. 
\\\\
\textbf{Expressive} This design goal only applies to the programming model. The programming model needs to be easy to express ideas, algorithms, tasks in an easy-to-read and succinct way.
\\\\
\textbf{Extensible} This design goal also only applies to the programming model. The programming model needs to flexible enough that if new capabilities are needed, they can be added to the software without major changes to the underlying architecture.

%\textbf{Portability} The service layer components should be able to be deployed in any cloud or edge enviroment. 
%The recent trend of emergence of heterogeneous subsystems in smart home environment often leads to interoperability problem in managing such systems. Interoperability is defined as the ability of two or more entities to exchange information and to use the information that has been exchanged [2]. In smart home environment, interoperability is concerned with message exchange between two or more subsystems and performing interoperation in a federated and satisfactory manner without the need for external intervention. 

\subsubsection{Rule Engine}

The Rule Engine makes it possible to evaluate data, perform decisions and trigger actions. The following are some of the work focused on the rule engine component.

Chui et al.~\cite{5277977} propose a rule-based system designed to support  heterogeneous IoT devices. The rule-based system is based on Event-Condition-Action (ECA) rule mechanism with SOAP technology. Chui et al. rule engine satisfies all the design goals since they use an Event-Condition-Action (ECA) pattern which allows them to scale the system as the number of rules grows and achieve low overhead.

Lica et. al~\cite{7314063} propose a rule-based architecture that addresses the main issues involved in application management in the Internet of Things. Lica et al. approach satisfies the expressive and extensible goals since further developments are necessary to improve the architecture effectiveness before its final implementation is carried out.

\subsubsection{Programming Models}
Due to the high dynamicity of edge resource, heterogeneity of Cloud and edge resources deploying low latency and scalable applications can be tricky. For this reason, there is a need for high-level programming models that simplify the development of IoT applications across the edge and the Cloud. The following are some of the work focused on the programming model component.

Mobile-Fog~\cite{Hong:2013} is a high-level programming model designed for applications that require large number of sensors and actuators and they are latency-sensitive. Mobile-Fog only satisfies both design goals since it uses a high-level API to program the sensors, making it easy to learn.

Ravel~\cite{ravel-riliskis-iotapp15} proposes a programming model to program applications across embedded devices, edge nodes and cloud nodes by  using an extension of the Model-View-Controller architecture. Ravel satisfies both design goals since it uses a high-level API. %Ravel introduces the concept of space, which binds particular models, controllers, and views to a specific device. The networking complexities between devices are hidden by the distributed model that automatically synchronizes whenever possible. 

Fabryq et al.~\cite{Etemadi2014FabryqUP} propose a proxy programming model to find and control sensors and actuators. Fabryq et al. approach also satisfies both design goals since it uses Javascript as the main programming language and also has a high-level API to program the sensors, making it easy to learn.

FogFlow~\cite{8022859} is a programming model that extends the dataflow programming model, allowing developers fast and easy development of edge and fog applications. FogFlow satisfies both design goals since it extends the Cloud dataflow programming model and makes it suitable for the edge environment, making it easy to learn.

\subsubsection{Workflow Orchestrator}

The Workflow Orchestrator consists of defining how to accommodate the application components (i.e., operators) on the available resources of the network topology to optimize one or more performance metrics~\cite{8752924}. The main challenge is to decide how to split the operators between the edge and Cloud in order to minimize the overall completion time. The workflow placement has been proved to be at least NP-Hard~\cite{Benoit:2013}. The following are some of the work focused only on the workflow orchestrator component.

Eidenbenz et al.~\cite{Eidenbenz:2016} present an algorithm for the Series-Parallel-Decomposable Graphs (SPDG). Eidenbenz et al. only satisfy the real-time design goals since its only a theoretical approach. %The algorithm is able to achieve a constant-factor approximation under the assumptions that the number of resources scales at least logarithmically with the number of computational tasks and the computational cost of the tasks dominates the cost of communication. 

Taneja et al.~\cite{Taneja:2017} propose an approach for deploying application across Cloud and edge resources by using a Module Mapping Algorithm. Taneja et al. meet all the design goals except for the dynamicity since the approach doesn't take into consideration network connectivity or failure of nodes.

DROPLET~\cite{8457776} is an algorithm, that partitions tasks across the edge and Cloud resources, while minimizing the total completion time. DROPLET achieves all the design goals since it is able to react and adapt to dynamic network events and is capable of performing real-time decisions and scale polynomially with increasing the number of operators to place. 

Ghosh et al.~\cite{Ghosh:2018} propose a Genetic Algorithm (GA) meta-heuristic for distributing analytics across edge and Cloud resources to support IoT applications. The main goal of the genetic algorithm is to minimize the end-to-end latency. Ghosh et al. only meet one of the design goals since it takes between 1 - 26 seconds for placing 1 - 50 operators, making it not real-time or scalable when the number of operators grows.

\begin{table}[h!]
\begin{adjustwidth}{1.8cm}{3cm}
\caption{Design goals of the security layer components of the cited papers in this survey.}
\label{tab:security}
\begin{tabular}{|c|c|c|}
\hline
Paper            & End-to-End Security       & Data Privacy              \\ \hline
Lu. et al.~\cite{7869305}       &                           & \checkmark \\ \hline
Shi et al.~\cite{shi}       &                           & \checkmark \\ \hline
Behrens et al.~\cite{7899405}    & \checkmark &                           \\ \hline
Mukherjee et al.~\cite{7987191} & \checkmark &                           \\ \hline
Kothmayr et al.~\cite{6424088}  & \checkmark &                           \\ \hline
\end{tabular}
\end{adjustwidth}
\end{table}

\subsection{Security Layer}
The fourth and last layer is the Security Layer, which consists of keeping the data generated by thousands of IoT devices private and secure. The following are some of the work focused on the end-to-end security component. Table~\ref{tab:security} summarizes the work focused on the security layer.

\subsubsection{Data privacy}

Since the IoT produces large volumes of data easily available privacy protection in IoT its a challenge. The following are some of the work focused only on the data privacy component.

Lu et al.~\cite{7869305} present a lightweight privacy-preserving data aggregation scheme designed to be used in constrained devices. The proposed aggregation schema uses the homomorphic Paillier encryption, Chinese Remainder Theorem, and one-way hash chain techniques to aggregate data.

Shi et al.~\cite{shi} propose an algorithm that allows users to upload encrypted data to an untrusted aggregator, and allows the aggregator to decrypt  statistics for each time interval.

\subsubsection{End-to-End Security}

In this section, we analyze the similarities and differences amongst all the currently available edge-based middleware systems that implement one or more of the layers of our edge-based middleware architecture. To do so we use the proposed edge platform architecture and the goals of each of the layers described in the previous section. Tables~\ref{tab:full_system_no_goals},\ref{tab:full_system_1},\ref{tab:full_system_2},\ref{tab:full_system_3} summarize and offer more details on all the edge middleware surveyed systems, including the design goals that each component satisfies.

AWS Greengrass~\cite{greengrass} is a software stack that allows to locally run computations, messaging, data caching, sync, and Machine Learning  capabilities on devices in a secure way. AWS Greengrass consists of all the four layers presented in section~\ref{sec:arch}. The main limitations of AWS Greengrass are the centralized architecture of the resource management layer, the lack of storage and query of the data processing layer, the use of a similar MQTT broker to Mosquitto for data ingestion violating the real-time design goal for the data processing layer, and the lack the workflow orchestration component in the service layer, leaving it to the end-user for the management and provisioning of the workflows.

Azure IoT Edge~\cite{azure} is a collection of services designed to create end-to-end IoT applications on Azure Cloud. This service is meant for analyzing data at the edge of the network, instead of in the Cloud. Azure IoT, similarly to AWS, takes security very seriously, and uses certificate-based authentication as the primary mechanism for authentication for the Azure IoT Edge platform. Azure IoT also implements all four layers proposed in section~\ref{fig:EdgeArch}. Azure IoT only misses two components: the first one is the workflow orchestrator from the service layer and the second one is the data privacy at the security layer. Azure IoT uses a similar MQTT broker to Mosquitto making it not able to achieve real-time analytics.

EAaaS~\cite{8029781} is an analytics service that enables real-time edge analytics in IoT scenarios. The main focus of the EAaaS is the uses of a unified rule-based analytic model to simplify the user's programming efforts. In addition, they put a great amount of attention on making the system as lightweight and scalable as possible. EAaaS implements two of the four layers; it does not implement the resource management layer or the security layer and misses some components on the layers that it implements. The first components missing are from the data processing layer: EAaaS does not allow the storage or query of data at the edge of the network. From the service layer, EAaS does not implement the workflow orchestrator, forcing the end-user to decide where to place computations to achieve optimal performance.

Google Cloud IoT Edge~\cite{google} is a collection of services that allows  users to manage, and consume IoT data from distributed devices at a large scale, and take actions as needed. Google Cloud IoT Edge follows the same path as the AWS Greengrass, implementing all four layers but missing some critical components on some of the layers. Google Cloud IoT Edge does not support the ability to store or query at the edge of the network. In addition, just like all the commercial systems surveyed so far, it also implements a similar broker to Mosquitto, violating the real-time design goal. Google Cloud IoT Edge does not offer the ability to orchestrate application between the edge and the Cloud.

Everyware IoT~\cite{everyware} is a comperical platform that provides an end-to-end IoT platform with propriotory software and hardware solutions. Everyware IoT implements all four layers but misses some critical components in all the layers. Similar to AWS, Azure, and Google, it lacks the query and storage support at the edge of the network and uses a similar Mosquitto broker for the data ingestion. Additionally, Everyware IoT lacks the rule engine of the service layer making it not possible to trigger or react to events that happen at the edge of the network.

Predix~\cite{predix} is General Electric's commercial software platform for the collection and analysis of data from industrial machines. Predix implements all four layers but misses some critical components. Predix does not offer resource monitoring, storage, or query. In addition, it also doesn't offer the ability to orchestrate workflows between the edge and the cloud.

Bosch IoT~\cite{bosch} is a commercial end-to-end IoT platform that consists of multiple Cloud-enabled services and software packages. Bosch IoT implements all four layers but misses some components. Bosch IoT does not offer the rule engine or the workflow orchestrator of the service layer, and just like all other commercial systems it also implements a similar broker to Mosquitto.

Yanzi~\cite{yanzi} is a commercial IoT platform designed to optimize office costs and productivity. Yanzi implements three of the four layers, lacking the resource management layer and some critical components on other layers. In the service layer, Yanzi misses the rule engine and the workflow orchestrator, and in the security layer, it misses the data privacy component.

R-Pulsar~\cite{8014357,8109157} is an academic platform software stack that lets you run local analytics, messaging, data storage, and data querying capabilities on edge devices. R-Pulsar is the only one that satisfies all four layers with the most design goals. In addition, is the only software stack that has a full memory-mapped pipeline making it truly real-time. Also, it's one of the few that offers a unified architecture between the edge and the core, allowing it to seamlessly program the edge and the core. A limitation that the majority of the software stacks present is a split platform architecture between the edge and the core, leaving the end user to manage the scalability, replication, and distribution to the end user. For platforms that use a single architecture such as R-Pulsar, the system takes care of it so the user can focus on developing the application. R-Pulsar is also the only one to offer any application objectives, all the other software do not any application objectives.

FogHorn~\cite{fogHorn} is a commercial software platform that enables to run advanced analytics and machine learning applications at the edge of the network. FogHorn implements all four layers but misses some critical components in some of the layers. In the data processing layer it misses the data storage and query components, not allowing the storage or query of data at the edge of the network. In the service layer, it misses the workflow orchestrator making the end user responsible for the management and provisioning of the resources and workflows. In the security layer, it misses the data privacy component.

GeeLytics~\cite{7389116} is an academic platform, which can perform real-time analytics either at the edge edge, or in the Cloud in a dynamic manner. Geelytics was designed to emphasize the service layer, in particular, the workflow orchestration component. Geelytics enables developers to run stream processing applications across the edge and the Cloud, without the need to consider where each task is located. GeeLytics implements two of the four layers, not implementing the security and the resource management layer. In addition, GeeLytics lacks the rule engine in the service layer and makes use of Mosquitto or Apache Kafka as the data ingestion data processing layer making it hard to scale or perform real-time analytics at the edge of the network.

Fogflow~\cite{8022859} is the evolution of GeeLytics, an academic framework that orchestrates workflows over the Cloud and the edge based on various context, including system context. For this second iteration they improved their workflow orchestration mechanism, added the missing rule engine component, and implemented the resource management layer. Some of the drawbacks existing on the previous version still have not been addressed, such as the use of Mosquitto or Kafka as the data ingestion component, limiting the scalability and the performance at the edge of the network.

OpenMTC~\cite{openMTC} is a commercial open-source implementation of an IoT/M2M middleware with the focus on providing a standard-compliant platform. OpenMTC implements three of the four layers, missing the resource management layer. In the data processing layer it does not allow the storage or query of data at the edge of the network, and just like any other commercial approach, it uses a similar MQTT broker for the data ingestion. In addition in the service layer, it misses the workflow orchestration.

SiteWhere~\cite{SiteWhere} is an industrial open-source platform, that uses a multi-tenant microservice-based infrastructure. SiteWhere implements all four layers and only misses very few components on some of the layers. In the service layer, it lacks the workflow orchestration and in the security layer, it lacks data privacy.

SmartThings~\cite{SmartThings} is a commercial IoT platform designed for the smart houses. SmartThings implements three of the four layers missing the resource management layer and lacks some major components in some layers. In the data processing layer lacks the ability to store or query data at the edge of the network. In the service layer, it also lacks the workflow orchestration.

Kaa~\cite{Kaa} is a commercial-grade IoT platform that is fully customizable. Kaa is one of the commercial systems more complete, implementing all four layers and missing very few components in some layers. The main drawback of Kaa is the lack of workflow orchestration between the edge and the Cloud, and the lack of data privacy in the security layer.

Samsung Artik~\cite{Samsung_Artik} is a commercial IoT platform that 
focuses on unifying hardware, software, the cloud and the edge as a single ecosystem. Samsung Artick implements three of the four layers, missing the resource management layer. The main drawback is the lack of two of the key components in the data processing layer: the storage and query components. In addition, like all other commercial systems, Artick uses an MQTT broker similar to Mosquitto for the data ingestion component.

Ayla Network~\cite{Ayla_Networks} is a commercial end-to-end IoT platform that includes a completely managed Cloud service. Ayla implements all the layers except for the resource management layer. In the data processing layer, it lacks the data storage and query and it uses an MQTT broker for the data ingestion layer. In addition, it also lacks the workflow orchestration component.

Altair SmartWorks~\cite{Altair_Smartworks} is a commercial platform designe as a Platform as a Service (PaaS) for Internet of Things projects, to collect data from objects, store it and build applications. Altair SmartWorks consists of three of the four layers, missing the data management layer. In the data processing layer, it lacks the ability to store and query data at the edge of the network. In also does not offer the ability to orchestrate workflows between the edge and the Cloud.

EdgeX~\cite{edgex} is a commercial open-source IoT microservice framework that allows end uses to chose their sensors from a large ecosystem of 3rd party offerings. EdgeX implements all four layers but lacks some of the components in most layers. In the data processing layer, EdgeX does not support the data storage or query. In addition like all other commercial systems, EdgeX uses an MQTT broker for the data ingestion violating the real-time design goal. In the service layer, it lacks the workflow orchestration.

PiCasso~\cite{8071529} is an academic orchestration engine that deploys services based on specifications and resources availability. PiCasso implements all the layers except for the security layer. PiCasso puts a lot of emphasis in the service layer more, in particular, the workflow orchestration component. PiCasso lacks the storage and query components of the data processing layers.

Hua-Jun Hong et al.~\cite{8241101} is an academic fog computing platform that that focuses on the task distribution between the edge and the cloud. Hua-Jun Hong et al. approach implements three of the four layers, missing the security layer. In addition, it misses most of the components in all layers, since the main focus of this platform is to make deployment decisions to maximize the number of satisfied IoT analytics (operator deployment problem). In the data processing layer lacks the ability to store and query data at the edge of the network.

Cloud4IoT~\cite{7830723} is an academic platform that focuses on automatically deploying and orchestrating IoT applications. Cloud4IoT implements all the layers except for the security layer. Cloud4IoT to ease the code interoperability between the edge and the Cloud, to do that relies on commercial software that was designed to be deployed on a large cluster, making it hard to achieve real-time analytics at the edge of the network.

Nebulae~\cite{Nebulae} is a commercial end-to-end IoT platform, which the main focus in interoperability and inter-portability. Nebulae implements three of the four layers missing the resource management layer. In the data processing layer, it lacks the ability to store and query data at the edge of the network. In the service layer, it lacks the rule engine and the workflow orchestrator.

FogGIS~\cite{7894725} is an academic framework for improving throughput and reducing latency for analysis of geospatial data. FogGIS implements all the layers except for the resource management layer. In addition, FogGIS data processing layer relies on a commercial system designed to be deployed on the Cloud not at the edge with constrained devices, making it hard to achieve real-time analytics.

FOG-engine~\cite{7588914} is an academic end-to-end platform for processing real-time analytics of data near where it is generated. FOG-engine implements two layers, not implementing the resource management and security layers, missing some key components on most layers. In the service layer, it lacks the orchestration and management of resources and workflows.

CEFIoT~\cite{8355149} is an academic end-to-end fault-tolerant architecture that reuses Cloud technologies at the edge of the network. CEFIoT implements two of the four layers, missing the resource management and security layers. In the service layer, it lacks the rule engine.

SAVI-IoT~\cite{8114487} is an academic self-managing programmable IoT platform that leverages both Hybrid Virtual Machines (HVV) and container isolation techniques to manage IoT applications. SAVI-IoT, just like CEFIoT, misses the same layers. The main difference is that SAVI-IoT does not offer a rule engine or a workflow orchestration. Another drawbacks of SAVI-IoT uses Kafka as the data ingestion component and Spark for the data analyses layer making them violate the real-time analytics at the edge of the network when deployed on constrained devices.

Foggy~\cite{8027267} is an academic architectural framework and software platform based on open-source technologies. Foggy main focus is the orchestration of application across the edge and the cloud. Foggy implements three of the four layers, missing the resource management layer. One of the main drawbacks of Foggy is the use of containers for orchestrating resources between the federated resource, making it no able to perform real-time analytics at the edge of the network. In addition, it lacks the ability to support storage and query at the edge of the network.

ISYMPHONY~\cite{8039055} is an academic orchestration framework designed for scaling real-time and on-demand IoT services. ISYMPHONY implements three of the four layers missing the security layer. ISYMPHONY focuses on the service layer in particular in the workflow orchestration layer. In the data processing layer, it lacks the data storage and query components. In addition, it lacks the rule engine in the service layer.

Macchina.io~\cite{Macchina.io} is a commercial IoT SDK that allows to connect sensors, actuators, Cloud services, mobile devices, and humans. Macchina.io implements three of the four layers, missing the resource management layer. In the service layer, it doesn't offer a rule-based engine or the workflow orchestration. In addition, Macchina.io relies on an MQTT broker similar to Mosquitto for the data ingestion layer.

Clearblade~\cite{Clearblade} is a commercial IoT platform to build scalable, secure enterprise IoT solutions. Clearblade implements three of the four layers, missing the resource management layer, and just like every other system it implements Mosquitto as their data ingestion component.

IBM Watson IoT Platform~\cite{IBM} is a commercial IoT platform that can connect and control IoT sensors, appliances, homes, and industries. The IBM Watson IoT Platform relies on the cloud to distribute and manage the edge analytics. IBM Watson IoT Platform implements all four layers proposed but misses the data storage and data query components of the data processing layer. Just like every other commercial systems surveyed above, it uses Mosquitto as their data ingestion component making it not scalable and real-time.

\input{Tables.tex}